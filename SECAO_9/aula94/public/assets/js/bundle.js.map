{"version":3,"sources":["webpack://aula93/./src/modulo1.js","webpack://aula93/webpack/bootstrap","webpack://aula93/webpack/runtime/define property getters","webpack://aula93/webpack/runtime/hasOwnProperty shorthand","webpack://aula93/webpack/runtime/make namespace object","webpack://aula93/./src/index.js"],"names":["nome","sobrenome","idade","soma","x","y","Pessoa","p1","console","log"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAO,IAAMA,IAAI,GAAG,WAAb,C,CAA0B;;AACjC,IAAMC,SAAS,GAAG,UAAlB;AACA,IAAMC,KAAK,GAAG,EAAd;;AAEA,SAASC,IAAT,CAAcC,CAAd,EAAiBC,CAAjB,EAAoB;AAClB,SAAOD,CAAC,GAAGC,CAAX;AACD,C,CAED;;;IACqBC,M,GACnB,gBAAYN,IAAZ,EAAkBC,SAAlB,EAA6B;AAAA;;AAC1B,OAAKD,IAAL,GAAYA,IAAb,EAAqB,KAAKC,SAAL,GAAiBA,SAAtC;AACD,C,EAGH;AACA;AAEA;AACA;;;;;;;;;;UCnBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AAEA,IAAMM,EAAE,GAAG,IAAID,6CAAJ,CAAWN,0CAAX,EAAiBC,+CAAjB,CAAX;AACAO,OAAO,CAACC,GAAR,CAAYF,EAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD","file":"bundle.js","sourcesContent":["export const nome = 'Joãozinho'; // exportando a variável nome diretamente\nconst sobrenome = 'Oliveira';\nconst idade = 30;\n\nfunction soma(x, y) {\n  return x + y;\n}\n\n// Exportando uma classe como default (apenas um default por arquivo)\nexport default class Pessoa {\n  constructor(nome, sobrenome) {\n    (this.nome = nome), (this.sobrenome = sobrenome);\n  }\n}\n\n// // Exportando função anônima como DEFAULT (apenas um default por arquivo)\n// export default (x, y) => x * y;\n\n// Exportando nossas variáveis e funções ao final do arquivo\n// As importaçõex/exportações podem ser renomeadas com a sintaxe \"as\"\nexport {sobrenome, idade, soma};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Importando as variáveis e funções que foram exportadas no modulo1\n// Podemos renomear variáveis importadas já na importação\n// As importações DEFAULT são chamadas fora das CHAVES e podem assumir qualquer nome\nimport Pessoa, {nome, sobrenome, idade, soma} from './modulo1';\n\nconst p1 = new Pessoa(nome, sobrenome);\nconsole.log(p1);\n\n/* \nIMPORT\n\nA declaração estática import é usada para importar vínculos que são exportados por um outro módulo. Os módulos importados estão em strict mode,  declarado como tal ou não. A declaração import não pode ser usada em scripts embutidos, a menos que tal script tenha um type=\"module\".\n\nHá também uma função dinâmica import(), que não requer scripts de type=\"module\".\n\nA compatibilidade com versões anteriores pode ser garantida usando o atributo nomodule na tag de script.\n\nA importação dinâmica é útil em situações em que você deseja carregar um módulo condicionalmente ou sob demanda. A forma estática é preferível para carregar dependências iniciais e pode se beneficiar mais prontamente de ferramentas de análise estática e tree shaking.\n\nSintaxe\nimport defaultExport from \"module-name\";\nimport * as name from \"module-name\";\nimport { export } from \"module-name\";\nimport { export as alias } from \"module-name\";\nimport { export1 , export2 } from \"module-name\";\nimport { foo , bar } from \"module-name/path/to/specific/un-exported/file\";\nimport { export1 , export2 as alias2 , [...] } from \"module-name\";\nimport defaultExport, { export [ , [...] ] } from \"module-name\";\nimport defaultExport, * as name from \"module-name\";\nimport \"module-name\"; var promise = import(\"module-name\"); // This is a stage 3 proposal.\n\n-defaultExport\nNome que de referência para a exportação padrão do módulo.\n\n-module-name\nO módulo para importar. Geralmente, esse é um nome de caminho relativo ou absoluto para o arquivo .js contendo esse módulo. Certos empacotadores podem permitir ou exigir o uso da extensão; verifique seu ambiente. Apenas aspas simples e aspas duplas são permitidas.\n\n-name\nNome do objeto do módulo que será usado como um tipo de espaço de nomes ao se referir às importações.\n\n-export, exportN\nNome das exportações a serem importadas.\n\n-alias, aliasN\nNomes que se referem às importações nomeadas.\n\nDescrição\nO parâmetro name é o nome do \"objeto módulo\", que será usado como um tipo de namespace para se referir às exportações. Os parâmetros de exportação especificam exportações nomeadas individuais, enquanto a importação * como sintaxe de nome importa todos eles. Abaixo estão alguns exemplos para esclarecer a sintaxe.\n\nImportar o conteúdo de todo um módulo\nIsso insere myModule no escopo atual, contendo todas as exportações do módulo no arquivo localizado em /modules/my-module.js.\n\nimport * as myModule from '/modules/my-module.js';\nAqui, acessar as exportações significa usar o nome do módulo (\"myModule\" neste caso) como um namespace. Por exemplo, se o módulo importado acima incluir um export doAllTheAmazingThings(), você o chamaria assim:\n\nmyModule.doAllTheAmazingThings();\nImportar uma única exportação de um módulo\nDado um objeto ou valor chamado myExportque foi exportado do módulo my-module  implicitamente (porque o módulo inteiro é exportado) ou explicitamente (usando a instrução export statement), isso insere  myExport no escopo atual.\n\nimport {myExport} from '/modules/my-module.js';\nImportar várias exportações do módulo\nIsso inclui tanto foo como bar  no escopo atual.\n\nImportar uma exportação com um alias mais conveniente\nVocê pode renomear uma exportação ao importá-la. Por exemplo, isso insere shortName no escopo atual.\n\n \n\nimport {reallyReallyLongModuleExportName as shortName}\n  from '/modules/my-module.js';\nRenomear várias exportações durante a importação\nImporte várias exportações de um módulo com aliases convenientes.\n\n \n\nimport {\n  reallyReallyLongModuleExportName as shortName,\n  anotherLongModuleName as short\n} from '/modules/my-module.js';\nImportar um módulo apenas para seus efeitos colaterais\nImporte um módulo inteiro somente para efeitos colaterais, sem importar nada. Isso executa o código global do módulo, mas na verdade não importa nenhum valor.\n\n \n\nimport '/modules/my-module.js';\nImportando Padrões\nÉ possível ter um padrão exportação (seja um objeto, uma função, uma classe etc.). A declaração de importação pode então ser usada para importar esses padrões.\n\n \n\nA versão mais simples importa diretamente o padrão:\n\n \n\nimport myDefault from '/modules/my-module.js';\n \n\nTambém é possível usar a sintaxe padrão como as vistas acima (importações de namespace ou importações nomeadas). Em tais casos, a importação padrão terá que ser declarada primeiro. Por exemplo:\n\n \n\nimport myDefault, * as myModule from '/modules/my-module.js';\n// myModule used as a namespace\nOu\n\n \n\nimport myDefault, {foo, bar} from '/modules/my-module.js';\n// specific, named imports\n \n\nImportações Dinâmicas\n \n\nA palavra-chave import pode ser chamada como uma função para importar dinamicamente um módulo. Quando usado dessa maneira, retorna uma promessa.\n\n \n\nimport('/modules/my-module.js')\n  .then((module) => {\n    // Do something with the module.\n  });\n \n\nEste formulário também suporta a palavra-chave await.\n\n \n\nlet module = await import('/modules/my-module.js'); */\n"],"sourceRoot":""}